name: Self Hosted Release

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
  workflow_dispatch:

permissions:
  packages: write

env:
  node: 22
  pnpm-version: 10

jobs:
  deploy-target:
    runs-on: ubuntu-latest
    outputs:
      latest_version: ${{ steps.deploy-target.outputs.latest_version }}
      is_latest: ${{ steps.deploy-target.outputs.is_latest }}
      is_prerelease: ${{ steps.deploy-target.outputs.is_prerelease }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-tags: true

      - name: Determine deploy target
        id: deploy-target
        run: |
          GITHUB_REF_NAME="${{ github.ref_name }}"
          VERSION="${GITHUB_REF_NAME#v}"  # Remove 'v' prefix
          echo "latest_version=$VERSION" >> $GITHUB_OUTPUT
          
          # Check if this is a prerelease (contains beta, alpha, rc, nightly)
          PRERELEASE="beta|alpha|rc|canary|nightly"
          
          if [[ "$VERSION" =~ ($PRERELEASE) ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "is_latest=false" >> $GITHUB_OUTPUT
            echo "This is a prerelease: $VERSION"
          else
            # For stable releases, check if this is actually the latest
            # Get all tags, filter out prereleases, sort by version, get the latest
            LATEST_STABLE=$(git tag -l 'v*' | grep -v -E "($PRERELEASE)" | sort -V | tail -n1)
            LATEST_STABLE="${LATEST_STABLE#v}"
          
            if [ "$VERSION" = "$LATEST_STABLE" ]; then
              echo "is_latest=true" >> $GITHUB_OUTPUT
              echo "This is the latest stable release: $VERSION"
            else
              echo "is_latest=false" >> $GITHUB_OUTPUT
              echo "This is a stable release but not the latest: $VERSION (latest is $LATEST_STABLE)"
            fi
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
          fi

  build:
    runs-on: ubuntu-latest
    needs: deploy-target
    strategy:
      fail-fast: false
      matrix:
        name: [ 'logchimp/api', 'logchimp/theme' ]

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.LC_SUBMODULES_TOKEN }}

      - name: Variables
        run: |
          service=${{ matrix.name }}
          SERVICE_NAME=$(basename "${service//-/-}")
          SERVICE_COMMON_NAME=$(echo "$SERVICE_NAME" | sed 's/-ee$//')
          
          echo "SERVICE_NAME=$SERVICE_NAME" >> $GITHUB_ENV
          echo "SERVICE_COMMON_NAME=$SERVICE_COMMON_NAME" >> $GITHUB_ENV
          echo "REGISTRY_OWNER=logchimp" >> $GITHUB_ENV
          echo "LATEST_VERSION=${{ needs.deploy-target.outputs.latest_version }}" >> $GITHUB_ENV
          echo "IS_LATEST=${{ needs.deploy-target.outputs.is_latest }}" >> $GITHUB_ENV
          echo "IS_PRERELEASE=${{ needs.deploy-target.outputs.is_prerelease }}" >> $GITHUB_ENV
          echo "This is the service name: $SERVICE_NAME and release version: ${{ needs.deploy-target.outputs.latest_version }}"

      - uses: actions/setup-node@v6
        with:
          node-version: ${{ env.node }}

      - uses: pnpm/action-setup@v4
        name: Install pnpm
        id: pnpm-install
        with:
          version: 10

      - name: Get pnpm store directory
        id: pnpm-cache
        run: echo "PNPM_CACHE_DIR=$(pnpm store path)" >> $GITHUB_ENV

      - name: Cache .pnpm-store
        uses: actions/cache@v4
        with:
          path: ${{ env.PNPM_CACHE_DIR }}
          key: ubuntu-node-v${{ env.node }}-pnpm-v${{ env.pnpm-version }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ubuntu-node-v${{ env.node }}-pnpm-v${{ env.pnpm-version }}-

      - name: Install packages
        run: pnpm install --frozen-lockfile

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build ${{ env.SERVICE_NAME }} Community Docker Image
        shell: bash
        env:
          DOCKER_BUILD_ARGUMENTS: >
            --cache-from type=registry,ref=ghcr.io/${{ env.REGISTRY_OWNER }}/cache:build-cache-${{ env.SERVICE_NAME }}-community
            --cache-to type=registry,ref=ghcr.io/${{ env.REGISTRY_OWNER }}/cache:build-cache-${{ env.SERVICE_NAME }}-community,mode=max
            --output=type=image,name=ghcr.io/${{ env.REGISTRY_OWNER }}/${{ env.SERVICE_NAME }},push-by-digest=true,name-canonical=true
        run: |
          # change 'api' to 'server'
          SERVICE_COMMON_NAME_LOCAL=$SERVICE_COMMON_NAME
          if [ "$SERVICE_COMMON_NAME_LOCAL" == "api" ]; then
            SERVICE_COMMON_NAME_LOCAL=server
          fi

          docker buildx build \
            --load -f ./packages/$SERVICE_COMMON_NAME_LOCAL/Dockerfile \
            --build-arg LOGCHIMP_VERSION=${{ env.LATEST_VERSION }} \
            -t logchimp-$SERVICE_COMMON_NAME . $DOCKER_BUILD_ARGUMENTS
          docker images

      - name: Tag and Push docker image
        shell: bash
        run: |
          # Always push the version tag
          docker tag logchimp-$SERVICE_COMMON_NAME ghcr.io/${{ env.REGISTRY_OWNER }}/${{ matrix.name }}:${{ env.LATEST_VERSION }}
          docker push ghcr.io/${{ env.REGISTRY_OWNER }}/${{ matrix.name }}:${{ env.LATEST_VERSION }}
          
          # Only tag as 'latest' if this is the latest stable release
          if [ "$IS_LATEST" == "true" ]; then
            echo "Tagging as latest..."
            docker tag logchimp-$SERVICE_COMMON_NAME ghcr.io/${{ env.REGISTRY_OWNER }}/${{ matrix.name }}:latest
            docker push ghcr.io/${{ env.REGISTRY_OWNER }}/${{ matrix.name }}:latest
          else
            echo "Skipping 'latest' tag (IS_LATEST=$IS_LATEST, IS_PRERELEASE=$IS_PRERELEASE)"
          fi
